{
  "version": 3,
  "sources": ["../../path-browserify/index.js"],
  "sourcesContent": ["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\r\n// transplited with Babel\r\n\r\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n'use strict';\r\n\r\nfunction assertPath(path) {\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\r\n  }\r\n}\r\n\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeStringPosix(path, allowAboveRoot) {\r\n  var res = '';\r\n  var lastSegmentLength = 0;\r\n  var lastSlash = -1;\r\n  var dots = 0;\r\n  var code;\r\n  for (var i = 0; i <= path.length; ++i) {\r\n    if (i < path.length)\r\n      code = path.charCodeAt(i);\r\n    else if (code === 47 /*/*/)\r\n      break;\r\n    else\r\n      code = 47 /*/*/;\r\n    if (code === 47 /*/*/) {\r\n      if (lastSlash === i - 1 || dots === 1) {\r\n        // NOOP\r\n      } else if (lastSlash !== i - 1 && dots === 2) {\r\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\r\n          if (res.length > 2) {\r\n            var lastSlashIndex = res.lastIndexOf('/');\r\n            if (lastSlashIndex !== res.length - 1) {\r\n              if (lastSlashIndex === -1) {\r\n                res = '';\r\n                lastSegmentLength = 0;\r\n              } else {\r\n                res = res.slice(0, lastSlashIndex);\r\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\r\n              }\r\n              lastSlash = i;\r\n              dots = 0;\r\n              continue;\r\n            }\r\n          } else if (res.length === 2 || res.length === 1) {\r\n            res = '';\r\n            lastSegmentLength = 0;\r\n            lastSlash = i;\r\n            dots = 0;\r\n            continue;\r\n          }\r\n        }\r\n        if (allowAboveRoot) {\r\n          if (res.length > 0)\r\n            res += '/..';\r\n          else\r\n            res = '..';\r\n          lastSegmentLength = 2;\r\n        }\r\n      } else {\r\n        if (res.length > 0)\r\n          res += '/' + path.slice(lastSlash + 1, i);\r\n        else\r\n          res = path.slice(lastSlash + 1, i);\r\n        lastSegmentLength = i - lastSlash - 1;\r\n      }\r\n      lastSlash = i;\r\n      dots = 0;\r\n    } else if (code === 46 /*.*/ && dots !== -1) {\r\n      ++dots;\r\n    } else {\r\n      dots = -1;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction _format(sep, pathObject) {\r\n  var dir = pathObject.dir || pathObject.root;\r\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir === pathObject.root) {\r\n    return dir + base;\r\n  }\r\n  return dir + sep + base;\r\n}\r\n\r\nvar posix = {\r\n  // path.resolve([from ...], to)\r\n  resolve: function resolve() {\r\n    var resolvedPath = '';\r\n    var resolvedAbsolute = false;\r\n    var cwd;\r\n\r\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n      var path;\r\n      if (i >= 0)\r\n        path = arguments[i];\r\n      else {\r\n        if (cwd === undefined)\r\n          cwd = process.cwd();\r\n        path = cwd;\r\n      }\r\n\r\n      assertPath(path);\r\n\r\n      // Skip empty entries\r\n      if (path.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      resolvedPath = path + '/' + resolvedPath;\r\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\r\n    }\r\n\r\n    // At this point the path should be resolved to a full absolute path, but\r\n    // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n    // Normalize the path\r\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\r\n\r\n    if (resolvedAbsolute) {\r\n      if (resolvedPath.length > 0)\r\n        return '/' + resolvedPath;\r\n      else\r\n        return '/';\r\n    } else if (resolvedPath.length > 0) {\r\n      return resolvedPath;\r\n    } else {\r\n      return '.';\r\n    }\r\n  },\r\n\r\n  normalize: function normalize(path) {\r\n    assertPath(path);\r\n\r\n    if (path.length === 0) return '.';\r\n\r\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\r\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\r\n\r\n    // Normalize the path\r\n    path = normalizeStringPosix(path, !isAbsolute);\r\n\r\n    if (path.length === 0 && !isAbsolute) path = '.';\r\n    if (path.length > 0 && trailingSeparator) path += '/';\r\n\r\n    if (isAbsolute) return '/' + path;\r\n    return path;\r\n  },\r\n\r\n  isAbsolute: function isAbsolute(path) {\r\n    assertPath(path);\r\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\r\n  },\r\n\r\n  join: function join() {\r\n    if (arguments.length === 0)\r\n      return '.';\r\n    var joined;\r\n    for (var i = 0; i < arguments.length; ++i) {\r\n      var arg = arguments[i];\r\n      assertPath(arg);\r\n      if (arg.length > 0) {\r\n        if (joined === undefined)\r\n          joined = arg;\r\n        else\r\n          joined += '/' + arg;\r\n      }\r\n    }\r\n    if (joined === undefined)\r\n      return '.';\r\n    return posix.normalize(joined);\r\n  },\r\n\r\n  relative: function relative(from, to) {\r\n    assertPath(from);\r\n    assertPath(to);\r\n\r\n    if (from === to) return '';\r\n\r\n    from = posix.resolve(from);\r\n    to = posix.resolve(to);\r\n\r\n    if (from === to) return '';\r\n\r\n    // Trim any leading backslashes\r\n    var fromStart = 1;\r\n    for (; fromStart < from.length; ++fromStart) {\r\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\r\n        break;\r\n    }\r\n    var fromEnd = from.length;\r\n    var fromLen = fromEnd - fromStart;\r\n\r\n    // Trim any leading backslashes\r\n    var toStart = 1;\r\n    for (; toStart < to.length; ++toStart) {\r\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\r\n        break;\r\n    }\r\n    var toEnd = to.length;\r\n    var toLen = toEnd - toStart;\r\n\r\n    // Compare paths to find the longest common path from root\r\n    var length = fromLen < toLen ? fromLen : toLen;\r\n    var lastCommonSep = -1;\r\n    var i = 0;\r\n    for (; i <= length; ++i) {\r\n      if (i === length) {\r\n        if (toLen > length) {\r\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\r\n            // We get here if `from` is the exact base path for `to`.\r\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n            return to.slice(toStart + i + 1);\r\n          } else if (i === 0) {\r\n            // We get here if `from` is the root\r\n            // For example: from='/'; to='/foo'\r\n            return to.slice(toStart + i);\r\n          }\r\n        } else if (fromLen > length) {\r\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\r\n            // We get here if `to` is the exact base path for `from`.\r\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n            lastCommonSep = i;\r\n          } else if (i === 0) {\r\n            // We get here if `to` is the root.\r\n            // For example: from='/foo'; to='/'\r\n            lastCommonSep = 0;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      var fromCode = from.charCodeAt(fromStart + i);\r\n      var toCode = to.charCodeAt(toStart + i);\r\n      if (fromCode !== toCode)\r\n        break;\r\n      else if (fromCode === 47 /*/*/)\r\n        lastCommonSep = i;\r\n    }\r\n\r\n    var out = '';\r\n    // Generate the relative path based on the path difference between `to`\r\n    // and `from`\r\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\r\n        if (out.length === 0)\r\n          out += '..';\r\n        else\r\n          out += '/..';\r\n      }\r\n    }\r\n\r\n    // Lastly, append the rest of the destination (`to`) path that comes after\r\n    // the common path parts\r\n    if (out.length > 0)\r\n      return out + to.slice(toStart + lastCommonSep);\r\n    else {\r\n      toStart += lastCommonSep;\r\n      if (to.charCodeAt(toStart) === 47 /*/*/)\r\n        ++toStart;\r\n      return to.slice(toStart);\r\n    }\r\n  },\r\n\r\n  _makeLong: function _makeLong(path) {\r\n    return path;\r\n  },\r\n\r\n  dirname: function dirname(path) {\r\n    assertPath(path);\r\n    if (path.length === 0) return '.';\r\n    var code = path.charCodeAt(0);\r\n    var hasRoot = code === 47 /*/*/;\r\n    var end = -1;\r\n    var matchedSlash = true;\r\n    for (var i = path.length - 1; i >= 1; --i) {\r\n      code = path.charCodeAt(i);\r\n      if (code === 47 /*/*/) {\r\n          if (!matchedSlash) {\r\n            end = i;\r\n            break;\r\n          }\r\n        } else {\r\n        // We saw the first non-path separator\r\n        matchedSlash = false;\r\n      }\r\n    }\r\n\r\n    if (end === -1) return hasRoot ? '/' : '.';\r\n    if (hasRoot && end === 1) return '//';\r\n    return path.slice(0, end);\r\n  },\r\n\r\n  basename: function basename(path, ext) {\r\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\r\n    assertPath(path);\r\n\r\n    var start = 0;\r\n    var end = -1;\r\n    var matchedSlash = true;\r\n    var i;\r\n\r\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n      if (ext.length === path.length && ext === path) return '';\r\n      var extIdx = ext.length - 1;\r\n      var firstNonSlashEnd = -1;\r\n      for (i = path.length - 1; i >= 0; --i) {\r\n        var code = path.charCodeAt(i);\r\n        if (code === 47 /*/*/) {\r\n            // If we reached a path separator that was not part of a set of path\r\n            // separators at the end of the string, stop now\r\n            if (!matchedSlash) {\r\n              start = i + 1;\r\n              break;\r\n            }\r\n          } else {\r\n          if (firstNonSlashEnd === -1) {\r\n            // We saw the first non-path separator, remember this index in case\r\n            // we need it if the extension ends up not matching\r\n            matchedSlash = false;\r\n            firstNonSlashEnd = i + 1;\r\n          }\r\n          if (extIdx >= 0) {\r\n            // Try to match the explicit extension\r\n            if (code === ext.charCodeAt(extIdx)) {\r\n              if (--extIdx === -1) {\r\n                // We matched the extension, so mark this as the end of our path\r\n                // component\r\n                end = i;\r\n              }\r\n            } else {\r\n              // Extension does not match, so our result is the entire path\r\n              // component\r\n              extIdx = -1;\r\n              end = firstNonSlashEnd;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\r\n      return path.slice(start, end);\r\n    } else {\r\n      for (i = path.length - 1; i >= 0; --i) {\r\n        if (path.charCodeAt(i) === 47 /*/*/) {\r\n            // If we reached a path separator that was not part of a set of path\r\n            // separators at the end of the string, stop now\r\n            if (!matchedSlash) {\r\n              start = i + 1;\r\n              break;\r\n            }\r\n          } else if (end === -1) {\r\n          // We saw the first non-path separator, mark this as the end of our\r\n          // path component\r\n          matchedSlash = false;\r\n          end = i + 1;\r\n        }\r\n      }\r\n\r\n      if (end === -1) return '';\r\n      return path.slice(start, end);\r\n    }\r\n  },\r\n\r\n  extname: function extname(path) {\r\n    assertPath(path);\r\n    var startDot = -1;\r\n    var startPart = 0;\r\n    var end = -1;\r\n    var matchedSlash = true;\r\n    // Track the state of characters (if any) we see before our first dot and\r\n    // after any path separator we find\r\n    var preDotState = 0;\r\n    for (var i = path.length - 1; i >= 0; --i) {\r\n      var code = path.charCodeAt(i);\r\n      if (code === 47 /*/*/) {\r\n          // If we reached a path separator that was not part of a set of path\r\n          // separators at the end of the string, stop now\r\n          if (!matchedSlash) {\r\n            startPart = i + 1;\r\n            break;\r\n          }\r\n          continue;\r\n        }\r\n      if (end === -1) {\r\n        // We saw the first non-path separator, mark this as the end of our\r\n        // extension\r\n        matchedSlash = false;\r\n        end = i + 1;\r\n      }\r\n      if (code === 46 /*.*/) {\r\n          // If this is our first dot, mark it as the start of our extension\r\n          if (startDot === -1)\r\n            startDot = i;\r\n          else if (preDotState !== 1)\r\n            preDotState = 1;\r\n      } else if (startDot !== -1) {\r\n        // We saw a non-dot and non-path separator before our dot, so we should\r\n        // have a good chance at having a non-empty extension\r\n        preDotState = -1;\r\n      }\r\n    }\r\n\r\n    if (startDot === -1 || end === -1 ||\r\n        // We saw a non-dot character immediately before the dot\r\n        preDotState === 0 ||\r\n        // The (right-most) trimmed path component is exactly '..'\r\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n      return '';\r\n    }\r\n    return path.slice(startDot, end);\r\n  },\r\n\r\n  format: function format(pathObject) {\r\n    if (pathObject === null || typeof pathObject !== 'object') {\r\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\r\n    }\r\n    return _format('/', pathObject);\r\n  },\r\n\r\n  parse: function parse(path) {\r\n    assertPath(path);\r\n\r\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n    if (path.length === 0) return ret;\r\n    var code = path.charCodeAt(0);\r\n    var isAbsolute = code === 47 /*/*/;\r\n    var start;\r\n    if (isAbsolute) {\r\n      ret.root = '/';\r\n      start = 1;\r\n    } else {\r\n      start = 0;\r\n    }\r\n    var startDot = -1;\r\n    var startPart = 0;\r\n    var end = -1;\r\n    var matchedSlash = true;\r\n    var i = path.length - 1;\r\n\r\n    // Track the state of characters (if any) we see before our first dot and\r\n    // after any path separator we find\r\n    var preDotState = 0;\r\n\r\n    // Get non-dir info\r\n    for (; i >= start; --i) {\r\n      code = path.charCodeAt(i);\r\n      if (code === 47 /*/*/) {\r\n          // If we reached a path separator that was not part of a set of path\r\n          // separators at the end of the string, stop now\r\n          if (!matchedSlash) {\r\n            startPart = i + 1;\r\n            break;\r\n          }\r\n          continue;\r\n        }\r\n      if (end === -1) {\r\n        // We saw the first non-path separator, mark this as the end of our\r\n        // extension\r\n        matchedSlash = false;\r\n        end = i + 1;\r\n      }\r\n      if (code === 46 /*.*/) {\r\n          // If this is our first dot, mark it as the start of our extension\r\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\r\n        } else if (startDot !== -1) {\r\n        // We saw a non-dot and non-path separator before our dot, so we should\r\n        // have a good chance at having a non-empty extension\r\n        preDotState = -1;\r\n      }\r\n    }\r\n\r\n    if (startDot === -1 || end === -1 ||\r\n    // We saw a non-dot character immediately before the dot\r\n    preDotState === 0 ||\r\n    // The (right-most) trimmed path component is exactly '..'\r\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\r\n      if (end !== -1) {\r\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\r\n      }\r\n    } else {\r\n      if (startPart === 0 && isAbsolute) {\r\n        ret.name = path.slice(1, startDot);\r\n        ret.base = path.slice(1, end);\r\n      } else {\r\n        ret.name = path.slice(startPart, startDot);\r\n        ret.base = path.slice(startPart, end);\r\n      }\r\n      ret.ext = path.slice(startDot, end);\r\n    }\r\n\r\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\r\n\r\n    return ret;\r\n  },\r\n\r\n  sep: '/',\r\n  delimiter: ':',\r\n  win32: null,\r\n  posix: null\r\n};\r\n\r\nposix.posix = posix;\r\n\r\nmodule.exports = posix;\r\n"],
  "mappings": ";;;;;AAAA;AAAA;AA0BA,aAAS,WAAW,MAAM;AACxB,UAAI,OAAO,SAAS,UAAU;AAC5B,cAAM,IAAI,UAAU,qCAAqC,KAAK,UAAU,IAAI,CAAC;AAAA,MAC/E;AAAA,IACF;AAGA,aAAS,qBAAqB,MAAM,gBAAgB;AAClD,UAAI,MAAM;AACV,UAAI,oBAAoB;AACxB,UAAI,YAAY;AAChB,UAAI,OAAO;AACX,UAAI;AACJ,eAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,EAAE,GAAG;AACrC,YAAI,IAAI,KAAK;AACX,iBAAO,KAAK,WAAW,CAAC;AAAA,iBACjB,SAAS;AAChB;AAAA;AAEA,iBAAO;AACT,YAAI,SAAS,IAAU;AACrB,cAAI,cAAc,IAAI,KAAK,SAAS,GAAG;AAAA,UAEvC,WAAW,cAAc,IAAI,KAAK,SAAS,GAAG;AAC5C,gBAAI,IAAI,SAAS,KAAK,sBAAsB,KAAK,IAAI,WAAW,IAAI,SAAS,CAAC,MAAM,MAAY,IAAI,WAAW,IAAI,SAAS,CAAC,MAAM,IAAU;AAC3I,kBAAI,IAAI,SAAS,GAAG;AAClB,oBAAI,iBAAiB,IAAI,YAAY,GAAG;AACxC,oBAAI,mBAAmB,IAAI,SAAS,GAAG;AACrC,sBAAI,mBAAmB,IAAI;AACzB,0BAAM;AACN,wCAAoB;AAAA,kBACtB,OAAO;AACL,0BAAM,IAAI,MAAM,GAAG,cAAc;AACjC,wCAAoB,IAAI,SAAS,IAAI,IAAI,YAAY,GAAG;AAAA,kBAC1D;AACA,8BAAY;AACZ,yBAAO;AACP;AAAA,gBACF;AAAA,cACF,WAAW,IAAI,WAAW,KAAK,IAAI,WAAW,GAAG;AAC/C,sBAAM;AACN,oCAAoB;AACpB,4BAAY;AACZ,uBAAO;AACP;AAAA,cACF;AAAA,YACF;AACA,gBAAI,gBAAgB;AAClB,kBAAI,IAAI,SAAS;AACf,uBAAO;AAAA;AAEP,sBAAM;AACR,kCAAoB;AAAA,YACtB;AAAA,UACF,OAAO;AACL,gBAAI,IAAI,SAAS;AACf,qBAAO,MAAM,KAAK,MAAM,YAAY,GAAG,CAAC;AAAA;AAExC,oBAAM,KAAK,MAAM,YAAY,GAAG,CAAC;AACnC,gCAAoB,IAAI,YAAY;AAAA,UACtC;AACA,sBAAY;AACZ,iBAAO;AAAA,QACT,WAAW,SAAS,MAAY,SAAS,IAAI;AAC3C,YAAE;AAAA,QACJ,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,aAAS,QAAQ,KAAK,YAAY;AAChC,UAAI,MAAM,WAAW,OAAO,WAAW;AACvC,UAAI,OAAO,WAAW,SAAS,WAAW,QAAQ,OAAO,WAAW,OAAO;AAC3E,UAAI,CAAC,KAAK;AACR,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,WAAW,MAAM;AAC3B,eAAO,MAAM;AAAA,MACf;AACA,aAAO,MAAM,MAAM;AAAA,IACrB;AAEA,QAAI,QAAQ;AAAA;AAAA,MAEV,SAAS,SAAS,UAAU;AAC1B,YAAI,eAAe;AACnB,YAAI,mBAAmB;AACvB,YAAI;AAEJ,iBAAS,IAAI,UAAU,SAAS,GAAG,KAAK,MAAM,CAAC,kBAAkB,KAAK;AACpE,cAAI;AACJ,cAAI,KAAK;AACP,mBAAO,UAAU,CAAC;AAAA,eACf;AACH,gBAAI,QAAQ;AACV,oBAAM,QAAQ,IAAI;AACpB,mBAAO;AAAA,UACT;AAEA,qBAAW,IAAI;AAGf,cAAI,KAAK,WAAW,GAAG;AACrB;AAAA,UACF;AAEA,yBAAe,OAAO,MAAM;AAC5B,6BAAmB,KAAK,WAAW,CAAC,MAAM;AAAA,QAC5C;AAMA,uBAAe,qBAAqB,cAAc,CAAC,gBAAgB;AAEnE,YAAI,kBAAkB;AACpB,cAAI,aAAa,SAAS;AACxB,mBAAO,MAAM;AAAA;AAEb,mBAAO;AAAA,QACX,WAAW,aAAa,SAAS,GAAG;AAClC,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,MAEA,WAAW,SAAS,UAAU,MAAM;AAClC,mBAAW,IAAI;AAEf,YAAI,KAAK,WAAW,EAAG,QAAO;AAE9B,YAAI,aAAa,KAAK,WAAW,CAAC,MAAM;AACxC,YAAI,oBAAoB,KAAK,WAAW,KAAK,SAAS,CAAC,MAAM;AAG7D,eAAO,qBAAqB,MAAM,CAAC,UAAU;AAE7C,YAAI,KAAK,WAAW,KAAK,CAAC,WAAY,QAAO;AAC7C,YAAI,KAAK,SAAS,KAAK,kBAAmB,SAAQ;AAElD,YAAI,WAAY,QAAO,MAAM;AAC7B,eAAO;AAAA,MACT;AAAA,MAEA,YAAY,SAAS,WAAW,MAAM;AACpC,mBAAW,IAAI;AACf,eAAO,KAAK,SAAS,KAAK,KAAK,WAAW,CAAC,MAAM;AAAA,MACnD;AAAA,MAEA,MAAM,SAAS,OAAO;AACpB,YAAI,UAAU,WAAW;AACvB,iBAAO;AACT,YAAI;AACJ,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,EAAE,GAAG;AACzC,cAAI,MAAM,UAAU,CAAC;AACrB,qBAAW,GAAG;AACd,cAAI,IAAI,SAAS,GAAG;AAClB,gBAAI,WAAW;AACb,uBAAS;AAAA;AAET,wBAAU,MAAM;AAAA,UACpB;AAAA,QACF;AACA,YAAI,WAAW;AACb,iBAAO;AACT,eAAO,MAAM,UAAU,MAAM;AAAA,MAC/B;AAAA,MAEA,UAAU,SAAS,SAAS,MAAM,IAAI;AACpC,mBAAW,IAAI;AACf,mBAAW,EAAE;AAEb,YAAI,SAAS,GAAI,QAAO;AAExB,eAAO,MAAM,QAAQ,IAAI;AACzB,aAAK,MAAM,QAAQ,EAAE;AAErB,YAAI,SAAS,GAAI,QAAO;AAGxB,YAAI,YAAY;AAChB,eAAO,YAAY,KAAK,QAAQ,EAAE,WAAW;AAC3C,cAAI,KAAK,WAAW,SAAS,MAAM;AACjC;AAAA,QACJ;AACA,YAAI,UAAU,KAAK;AACnB,YAAI,UAAU,UAAU;AAGxB,YAAI,UAAU;AACd,eAAO,UAAU,GAAG,QAAQ,EAAE,SAAS;AACrC,cAAI,GAAG,WAAW,OAAO,MAAM;AAC7B;AAAA,QACJ;AACA,YAAI,QAAQ,GAAG;AACf,YAAI,QAAQ,QAAQ;AAGpB,YAAI,SAAS,UAAU,QAAQ,UAAU;AACzC,YAAI,gBAAgB;AACpB,YAAI,IAAI;AACR,eAAO,KAAK,QAAQ,EAAE,GAAG;AACvB,cAAI,MAAM,QAAQ;AAChB,gBAAI,QAAQ,QAAQ;AAClB,kBAAI,GAAG,WAAW,UAAU,CAAC,MAAM,IAAU;AAG3C,uBAAO,GAAG,MAAM,UAAU,IAAI,CAAC;AAAA,cACjC,WAAW,MAAM,GAAG;AAGlB,uBAAO,GAAG,MAAM,UAAU,CAAC;AAAA,cAC7B;AAAA,YACF,WAAW,UAAU,QAAQ;AAC3B,kBAAI,KAAK,WAAW,YAAY,CAAC,MAAM,IAAU;AAG/C,gCAAgB;AAAA,cAClB,WAAW,MAAM,GAAG;AAGlB,gCAAgB;AAAA,cAClB;AAAA,YACF;AACA;AAAA,UACF;AACA,cAAI,WAAW,KAAK,WAAW,YAAY,CAAC;AAC5C,cAAI,SAAS,GAAG,WAAW,UAAU,CAAC;AACtC,cAAI,aAAa;AACf;AAAA,mBACO,aAAa;AACpB,4BAAgB;AAAA,QACpB;AAEA,YAAI,MAAM;AAGV,aAAK,IAAI,YAAY,gBAAgB,GAAG,KAAK,SAAS,EAAE,GAAG;AACzD,cAAI,MAAM,WAAW,KAAK,WAAW,CAAC,MAAM,IAAU;AACpD,gBAAI,IAAI,WAAW;AACjB,qBAAO;AAAA;AAEP,qBAAO;AAAA,UACX;AAAA,QACF;AAIA,YAAI,IAAI,SAAS;AACf,iBAAO,MAAM,GAAG,MAAM,UAAU,aAAa;AAAA,aAC1C;AACH,qBAAW;AACX,cAAI,GAAG,WAAW,OAAO,MAAM;AAC7B,cAAE;AACJ,iBAAO,GAAG,MAAM,OAAO;AAAA,QACzB;AAAA,MACF;AAAA,MAEA,WAAW,SAAS,UAAU,MAAM;AAClC,eAAO;AAAA,MACT;AAAA,MAEA,SAAS,SAAS,QAAQ,MAAM;AAC9B,mBAAW,IAAI;AACf,YAAI,KAAK,WAAW,EAAG,QAAO;AAC9B,YAAI,OAAO,KAAK,WAAW,CAAC;AAC5B,YAAI,UAAU,SAAS;AACvB,YAAI,MAAM;AACV,YAAI,eAAe;AACnB,iBAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACzC,iBAAO,KAAK,WAAW,CAAC;AACxB,cAAI,SAAS,IAAU;AACnB,gBAAI,CAAC,cAAc;AACjB,oBAAM;AACN;AAAA,YACF;AAAA,UACF,OAAO;AAEP,2BAAe;AAAA,UACjB;AAAA,QACF;AAEA,YAAI,QAAQ,GAAI,QAAO,UAAU,MAAM;AACvC,YAAI,WAAW,QAAQ,EAAG,QAAO;AACjC,eAAO,KAAK,MAAM,GAAG,GAAG;AAAA,MAC1B;AAAA,MAEA,UAAU,SAAS,SAAS,MAAM,KAAK;AACrC,YAAI,QAAQ,UAAa,OAAO,QAAQ,SAAU,OAAM,IAAI,UAAU,iCAAiC;AACvG,mBAAW,IAAI;AAEf,YAAI,QAAQ;AACZ,YAAI,MAAM;AACV,YAAI,eAAe;AACnB,YAAI;AAEJ,YAAI,QAAQ,UAAa,IAAI,SAAS,KAAK,IAAI,UAAU,KAAK,QAAQ;AACpE,cAAI,IAAI,WAAW,KAAK,UAAU,QAAQ,KAAM,QAAO;AACvD,cAAI,SAAS,IAAI,SAAS;AAC1B,cAAI,mBAAmB;AACvB,eAAK,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACrC,gBAAI,OAAO,KAAK,WAAW,CAAC;AAC5B,gBAAI,SAAS,IAAU;AAGnB,kBAAI,CAAC,cAAc;AACjB,wBAAQ,IAAI;AACZ;AAAA,cACF;AAAA,YACF,OAAO;AACP,kBAAI,qBAAqB,IAAI;AAG3B,+BAAe;AACf,mCAAmB,IAAI;AAAA,cACzB;AACA,kBAAI,UAAU,GAAG;AAEf,oBAAI,SAAS,IAAI,WAAW,MAAM,GAAG;AACnC,sBAAI,EAAE,WAAW,IAAI;AAGnB,0BAAM;AAAA,kBACR;AAAA,gBACF,OAAO;AAGL,2BAAS;AACT,wBAAM;AAAA,gBACR;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,cAAI,UAAU,IAAK,OAAM;AAAA,mBAA0B,QAAQ,GAAI,OAAM,KAAK;AAC1E,iBAAO,KAAK,MAAM,OAAO,GAAG;AAAA,QAC9B,OAAO;AACL,eAAK,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACrC,gBAAI,KAAK,WAAW,CAAC,MAAM,IAAU;AAGjC,kBAAI,CAAC,cAAc;AACjB,wBAAQ,IAAI;AACZ;AAAA,cACF;AAAA,YACF,WAAW,QAAQ,IAAI;AAGvB,6BAAe;AACf,oBAAM,IAAI;AAAA,YACZ;AAAA,UACF;AAEA,cAAI,QAAQ,GAAI,QAAO;AACvB,iBAAO,KAAK,MAAM,OAAO,GAAG;AAAA,QAC9B;AAAA,MACF;AAAA,MAEA,SAAS,SAAS,QAAQ,MAAM;AAC9B,mBAAW,IAAI;AACf,YAAI,WAAW;AACf,YAAI,YAAY;AAChB,YAAI,MAAM;AACV,YAAI,eAAe;AAGnB,YAAI,cAAc;AAClB,iBAAS,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACzC,cAAI,OAAO,KAAK,WAAW,CAAC;AAC5B,cAAI,SAAS,IAAU;AAGnB,gBAAI,CAAC,cAAc;AACjB,0BAAY,IAAI;AAChB;AAAA,YACF;AACA;AAAA,UACF;AACF,cAAI,QAAQ,IAAI;AAGd,2BAAe;AACf,kBAAM,IAAI;AAAA,UACZ;AACA,cAAI,SAAS,IAAU;AAEnB,gBAAI,aAAa;AACf,yBAAW;AAAA,qBACJ,gBAAgB;AACvB,4BAAc;AAAA,UACpB,WAAW,aAAa,IAAI;AAG1B,0BAAc;AAAA,UAChB;AAAA,QACF;AAEA,YAAI,aAAa,MAAM,QAAQ;AAAA,QAE3B,gBAAgB;AAAA,QAEhB,gBAAgB,KAAK,aAAa,MAAM,KAAK,aAAa,YAAY,GAAG;AAC3E,iBAAO;AAAA,QACT;AACA,eAAO,KAAK,MAAM,UAAU,GAAG;AAAA,MACjC;AAAA,MAEA,QAAQ,SAAS,OAAO,YAAY;AAClC,YAAI,eAAe,QAAQ,OAAO,eAAe,UAAU;AACzD,gBAAM,IAAI,UAAU,qEAAqE,OAAO,UAAU;AAAA,QAC5G;AACA,eAAO,QAAQ,KAAK,UAAU;AAAA,MAChC;AAAA,MAEA,OAAO,SAAS,MAAM,MAAM;AAC1B,mBAAW,IAAI;AAEf,YAAI,MAAM,EAAE,MAAM,IAAI,KAAK,IAAI,MAAM,IAAI,KAAK,IAAI,MAAM,GAAG;AAC3D,YAAI,KAAK,WAAW,EAAG,QAAO;AAC9B,YAAI,OAAO,KAAK,WAAW,CAAC;AAC5B,YAAI,aAAa,SAAS;AAC1B,YAAI;AACJ,YAAI,YAAY;AACd,cAAI,OAAO;AACX,kBAAQ;AAAA,QACV,OAAO;AACL,kBAAQ;AAAA,QACV;AACA,YAAI,WAAW;AACf,YAAI,YAAY;AAChB,YAAI,MAAM;AACV,YAAI,eAAe;AACnB,YAAI,IAAI,KAAK,SAAS;AAItB,YAAI,cAAc;AAGlB,eAAO,KAAK,OAAO,EAAE,GAAG;AACtB,iBAAO,KAAK,WAAW,CAAC;AACxB,cAAI,SAAS,IAAU;AAGnB,gBAAI,CAAC,cAAc;AACjB,0BAAY,IAAI;AAChB;AAAA,YACF;AACA;AAAA,UACF;AACF,cAAI,QAAQ,IAAI;AAGd,2BAAe;AACf,kBAAM,IAAI;AAAA,UACZ;AACA,cAAI,SAAS,IAAU;AAEnB,gBAAI,aAAa,GAAI,YAAW;AAAA,qBAAW,gBAAgB,EAAG,eAAc;AAAA,UAC9E,WAAW,aAAa,IAAI;AAG5B,0BAAc;AAAA,UAChB;AAAA,QACF;AAEA,YAAI,aAAa,MAAM,QAAQ;AAAA,QAE/B,gBAAgB;AAAA,QAEhB,gBAAgB,KAAK,aAAa,MAAM,KAAK,aAAa,YAAY,GAAG;AACvE,cAAI,QAAQ,IAAI;AACd,gBAAI,cAAc,KAAK,WAAY,KAAI,OAAO,IAAI,OAAO,KAAK,MAAM,GAAG,GAAG;AAAA,gBAAO,KAAI,OAAO,IAAI,OAAO,KAAK,MAAM,WAAW,GAAG;AAAA,UAClI;AAAA,QACF,OAAO;AACL,cAAI,cAAc,KAAK,YAAY;AACjC,gBAAI,OAAO,KAAK,MAAM,GAAG,QAAQ;AACjC,gBAAI,OAAO,KAAK,MAAM,GAAG,GAAG;AAAA,UAC9B,OAAO;AACL,gBAAI,OAAO,KAAK,MAAM,WAAW,QAAQ;AACzC,gBAAI,OAAO,KAAK,MAAM,WAAW,GAAG;AAAA,UACtC;AACA,cAAI,MAAM,KAAK,MAAM,UAAU,GAAG;AAAA,QACpC;AAEA,YAAI,YAAY,EAAG,KAAI,MAAM,KAAK,MAAM,GAAG,YAAY,CAAC;AAAA,iBAAW,WAAY,KAAI,MAAM;AAEzF,eAAO;AAAA,MACT;AAAA,MAEA,KAAK;AAAA,MACL,WAAW;AAAA,MACX,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAEA,UAAM,QAAQ;AAEd,WAAO,UAAU;AAAA;AAAA;",
  "names": []
}
